.. api_guide_control_flow_en:

#############
Control flow
#############

In programming languages, the control flow determines the order in which statements are executed. Common control flows contain sequential execution, branching, and looping. PaddlePaddle Fluid inherits this concept and provides a variety of control flow APIs to control the execution logic of the deep learning model during training or prediction.

IfElse
======

Conditional branch, permitting different inputs to the same batch, according to the given conditions, select the logic in code:`true_block` or :code:`false_block` to execute respectively, and then merge the outputs of the two branches into one after the execution. In general, conditional expressions can be generated by a logical comparison API such as :ref:`api_fluid_layers_less_than`, :ref:`api_fluid_layers_equal`.

Please refer to :ref:`api_fluid_layers_IfElse`


Switch
======

Switch, like the :code:`switch-case` declaration commonly found in programming languages, selects different branch executions depending on the value of the input expression. Specifically, the :code:`Switch` control flow defined by Fluid has the following characteristics:

* The condition of the case is a bool type value, that is, a tensor type of Variable in the Program;
* Check each case one by one, select the first case execution that satisfies the condition, and exit the block after completion of the execution;
* If all cases do not meet the conditions, the default case will be selected for execution.

Please refer to :ref:`api_fluid_layers_Switch`

While
=====

While, when the condition is true, the loop executes :code:`While` The logic in the flow belongs to :code:`block`, and the condition is judged to be false and exits the loop. The related APIs are as follows:

* :ref:`api_fluid_layers_increment` : accumulated API, usually used to count the number of loops;
* :ref:`api_fluid_layers_array_read` : Read Variable from the location specified in :code:`LOD_TENSOR_ARRAY` to perform calculations;
* :ref:`api_fluid_layers_array_write` : Writes the Variable back to the location specified by :code:`LOD_TENSOR_ARRAY` and stores the result of the calculation.

Please refer to :ref:`api_fluid_layers_While`

DynamicRNN
==========

That is, the dynamic RNN can process a batch of unequal sequence data, which accepts the variable of code:`lod_level=1` as input, in the :code:`block` of :code:`DynamicRNN`, the user needs to customize RNN's single-step calculation logic. At each time step, the user can write the state to be remembered to :code:`memory` of :code:`DynamicRNN` and write the required output to its :code:`output`.

:ref:`api_fluid_layers_sequence_last_step` get the output of the last time step of :code:`DynamicRNN`.

Please refer to :ref:`api_fluid_layers_DynamicRNN`

StaticRNN
=========

That is, the static RNN can only process fixed-length sequence data, accepting Variable of :code:`lod_level=0` as input. Similar to :code:`DynamicRNN`, at each single time step of the RNN, the user needs to customize the calculation logic and write the status and output.

Please refer to :ref:`api_fluid_layers_StaticRNN`